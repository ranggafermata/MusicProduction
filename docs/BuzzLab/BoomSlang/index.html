<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BoomSlang</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">
 <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" defer></script>
  <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 20px;
            font-family: 'Roboto', Arial, sans-serif;
            background: linear-gradient(135deg, #2d2d2e 0%, #323233 50%, #46515f 100%);
            color: #ffffff;
            min-height: 100%;
            overflow-x: auto;
        }

        .container {
            width: 1200px;
            margin: 0 auto;
            background: linear-gradient(135deg, #2e2f30 0%, #1c6e79 50%, #312c31 100%);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        #presetBox {
            position: absolute;
            top: 30px;
            right: 40px;
        }

        .title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls-section {
            display: flex;
            justify-content: end;
            align-items: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .play-button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid rgba(78, 205, 196, 0.3);
            background: linear-gradient(140deg, #3e3e3f 0%, #2b4a4e 50%, #273336 100%);
            color: white;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 2px 8px rgba(255, 255, 255, 0.1);
        }

        .play-button:hover {
            border-color: rgba(80, 226, 216, 0.582);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.15);
        }

        .play-button.playing {
            border-color: rgba(205, 78, 127, 0.932);
            background: linear-gradient(140deg, #2d2d2e 0%, #264246 50%, #023342 100%);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.15);
        }

        .bpm-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            background: linear-gradient(140deg, #2d2d2e 0%, #264246 50%, #023342 100%);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 200px;
        }
        .main-control {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 24px;
            background: linear-gradient(140deg, #2d2d2e 0%, #264246 50%, #023342 100%);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 200px;
        }

        .bpm-label {
            font-weight: bold;
            color: #74cccc;
            font-size: 1.1rem;
        }

        .bpm-value {
            font-size: 2rem;
            font-weight: bold;
            color: #6bfaff;
        }

        .bpm-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }

        .bpm-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(140deg, #455864 0%, #55e4c5 50%, #179186 100%);
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(107, 233, 255, 0.4);
            transition: all 0.2s ease;
        }

        .bpm-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 16px rgba(255, 107, 107, 0.6);
        }

        .bpm-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(140deg, #455864 0%, #55e4c5 50%, #179186 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 12px rgba(107, 233, 255, 0.4);
            transition: all 0.2s ease;
        }

        .bpm-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 16px rgba(255, 107, 107, 0.6);
        }

        .visualizer-container {
            margin-bottom: 30px;
            background: linear-gradient(180deg, rgba(15, 32, 34, 0.85), rgba(14, 24, 27, 0.9));
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .visualizer {
            width: 100%;
            height: 150px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
        }

        .timeline-container {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(4, 105, 145, 0.1), 0 0 15px rgba(19, 177, 166, 0.1);
            margin-bottom: 20px;
        }

        .timeline-markers {
            display: grid;
            grid-template-columns: 150px repeat(16, 1fr);
            gap: 8px;
            margin-bottom: 10px;
        }

        .timeline-spacer {
            grid-column: 1;
        }

        .beat-marker {
            text-align: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: #4ecdc4;
            padding: 8px 0;
            border-radius: 6px;
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid rgba(78, 205, 196, 0.2);
            transition: all 0.15s ease;
        }

        .beat-marker.quarter {
            background: rgba(255, 107, 107, 0.2);
            border-color: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
            font-weight: 900;
        }

        .beat-marker.eighth {
            background: rgba(255, 206, 84, 0.15);
            border-color: rgba(255, 206, 84, 0.25);
            color: #ffce54;
            font-weight: 700;
        }

        .drum-grid {
            display: grid;
            grid-template-columns: 150px repeat(16, 1fr);
            gap: 8px;
        }

        .drum-label {
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            font-weight: bold;
            font-size: 0.9rem;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s ease;
        }

        .drum-label:hover {
            background: rgba(1, 26, 32, 0.952);
            cursor: pointer;
            transform: scale(1.03);
        }

        .step-button {
            aspect-ratio: 1;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .step-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .step-button.active {
            background: linear-gradient(45deg, #0dafa2, #07eea9);
            border-color: #6be1ff52;
            box-shadow: 0 4px 15px rgba(107, 245, 255, 0.4);
        }

        .step-button.current {
            border-color: #4ecdc4;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.6);
        }

        .kick { background: linear-gradient(140deg, #2d2d2e 0%, #264246 50%, #023342 100%); }
        .snare { background: linear-gradient(140deg, #2d2d2e 0%, #264246 50%, #023342 100%); }
        .hihat { background: linear-gradient(140deg, #2d2d2e 0%, #264246 50%, #023342 100%); }
        .openhat { background: linear-gradient(140deg, #2d2d2e 0%, #264246 50%, #023342 100%); }
        .crash { background: linear-gradient(140deg, #2d2d2e 0%, #264246 50%, #023342 100%); }
        .clap { background: linear-gradient(140deg, #2d2d2e 0%, #264246 50%, #023342 100%); }
        .fx { background: linear-gradient(140deg, #2d2d2e 0%, #264246 50%, #023342 100%); }
        .volume-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .volume-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 30px;
            margin-top: 20px;
            justify-items: center;
        }

        .volume-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .volume-label {
            font-weight: bold;
            color: #4ecdc4;
            font-size: 0.9rem;
        }

        .knob-container {
            position: relative;
            width: 80px;
            height: 80px;
        }

        .knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(140deg, #3e3e3f 0%, #2b4a4e 50%, #273336 100%);
            border: 3px solid rgba(78, 205, 196, 0.3);
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 2px 8px rgba(255, 255, 255, 0.1);
        }

        .knob:hover {
            border-color: rgba(80, 226, 216, 0.582);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.15);
        }

        .knob-indicator {
            position: absolute;
            top: -5px;
            left: 50%;
            width: 4px;
            height: 25%;
            background: linear-gradient(180deg, #ff6b6b 0%, #4ecdc4 100%);
            border-radius: 2px;
            transform-origin: center 250%;
            transform: translateX(-50%);
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.6);
        }

        .knob-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9rem;
            font-weight: bold;
            color: #ffffff;
        }

        .clear-button, #donateButton, .info-primary-btn {
            padding: 12px 24px;
            border: 3px solid rgba(78, 205, 196, 0.3);
            border-radius: 10px;
            background: linear-gradient(140deg, #3e3e3f 0%, #2b4a4e 50%, #273336 100%);
            color: rgba(209, 216, 216, 0.692);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .clear-button:hover, #donateButton:hover, .info-primary-btn:hover {
            border-color: rgba(80, 226, 216, 0.582);
            color: rgba(255, 255, 255, 0.842);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.15);
        }
        .form-select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid rgba(78, 205, 196, 0.3);
            background: linear-gradient(140deg, #afafb3 0%, #3d6368 50%, #4e676d 100%);
            color: rgb(44, 42, 42);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.15);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .form-select:hover {
            border-color: rgba(80, 226, 216, 0.582);
        }

        @media (max-width: 768px) {
            .drum-grid {
                grid-template-columns: 100px repeat(8, 1fr);
            }
            
            .controls-section {
                flex-direction: column;
                gap: 20px;
            }
            
            .title {
                font-size: 2rem;
            }
        }
        /* --- Custom Dark Scrollbar Styles --- */
    /* Works on Firefox */
      * {
        scrollbar-width: thin;
        scrollbar-color: #555 #2c2c2c;
        }

        /* Works on Chrome, Edge, and Safari */
        *::-webkit-scrollbar {
        width: 12px;
        }

        *::-webkit-scrollbar-track {
        background: #2c2c2c;
        }

        *::-webkit-scrollbar-thumb {
        background-color: #555;
        border-radius: 20px;
        border: 3px solid #2c2c2c;
        }

        *::-webkit-scrollbar-thumb:hover {
        background-color: #777;
        }
        .pan-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }

        .pan-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(140deg, #455264 0%, #89e455 50%, #178991 100%);
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(107, 233, 255, 0.4);
            transition: all 0.2s ease;
        }

        .pan-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 16px rgba(255, 107, 107, 0.6);
        }

        .pan-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(140deg, #455864 0%, #55e4c5 50%, #179186 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 12px rgba(107, 233, 255, 0.4);
            transition: all 0.2s ease;
        }

        .pan-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 16px rgba(255, 107, 107, 0.6);
        }
        
        /* Info splash overlay (shown when clicking the logo) */
   #info-splash-overlay, #donate-overlay {
     position: fixed;
     inset: 0;
     display: none;
     opacity: 0;
     visibility: hidden;
     transition: opacity 0.25s ease, visibility 0.25s ease;
     align-items: center;
     justify-content: center;
     z-index: 4000;
     background: rgba(10,10,10,0.7);
     backdrop-filter: blur(6px);
     -webkit-backdrop-filter: blur(6px);
     padding: 1rem;
   }
   #info-splash, #donate-splash {
     width: min(880px, 95%);
     background: linear-gradient(180deg, rgba(35,35,35,0.98), rgba(25,25,25,0.98));
     border-radius: 12px;
     padding: 1.25rem;
     color: #eee;
     animation: neon-light 3s ease-in-out infinite alternate;
     box-shadow:0 10px 40px rgba(0,0,0,0.6);
     max-height: 85vh;
     overflow: auto;
     text-align: left;
   }
   #info-splash h2, #donate-splash h2 {
     margin-top: 0;
     margin-bottom: 0.5rem;
   }
   #info-splash .meta, #donate-splash .meta {
     color: #bdbdbd;
     font-size: 0.9rem;
     margin-bottom: 1rem;
   }
   #info-splash .actions, #donate-splash .actions {
     display: flex;
     gap: 0.5rem;
     margin-top: 1rem;
     justify-content: flex-end;
   }
   .info-close-btn , .donate-close-btn {
     background: transparent;
     border: 1px solid rgba(255,255,255,0.06);
     color: #fff;
     padding: 0.4rem 0.8rem;
     border-radius: 6px;
     cursor: pointer;
   }
   
   @keyframes neon-light
    {
      0% {
        box-shadow:  #61cfe233 0px 0px 5px, 0 0 10px #61cfe233, 0 0 15px #61cfe233, 0 0 20px #61cfe233;
      }
      10% {
        box-shadow: 0 0 10px #61cfe233, 0 0 15px #61cfe233, 0 0 20px #61cfe233, 0 0 25px #61cfe233;
      }
    }
    </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div class="container">
   <header class="header">
    <img id="appTitle" src="assets/BoomSlangLogo4.png" class="img-fluid mb-3" alt="BoomSlang Logo" style="max-width:200px; cursor:pointer;" title="Click for info about BoomSlang">
    <!-- Donation Button-->
    <button id="donateButton" class="btn btn-primary" style="display:flex;flex-direction:column;align-items:center;" title="Support BoomSlang Development">☕ Donate</button>
    <!-- Preset selector -->
      <div id="presetBox" style="display:flex;flex-direction:column;align-items:center;" title="Select Drum Kit Preset">
        <label for="presetSelect" class="bpm-label" style="margin-bottom:6px;">Preset</label>
        <select id="presetSelect" class="form-select" style="min-width:160px;">
          <option value="classic">Supreme</option>
          <option value="electronic">Full House</option>
          <option value="acoustic">Trapper</option>
          <option value="Pop">Sweet Candy</option>
          <option value="default">-- default (Synth) --</option>
        </select>
      </div>
   </header>
   <div class="controls-section">
    
    <div class="control-group">
      <!-- Master Volume Knob -->
      <div class="main-control" style="min-width:160px; align-items:center;">
        <span class="bpm-label">Master</span>
        <div class="knob-container" style="margin-top:8px;">
          <div class="knob" id="masterKnob" tabindex="0" aria-label="Master Volume Knob" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="80" title="Master Volume">
            <div class="knob-indicator" id="masterIndicator"></div>
            <div class="knob-value" id="masterValue">80</div>
          </div>
        </div>
        <!-- Play/Pause Button -->
        <button class="play-button" title="Play button" id="playButton">▶</button>
      </div>
    </div>
    <!-- BPM Control -->
    <div class="bpm-control"><span class="bpm-label" id="bpmLabel">BPM</span> <span class="bpm-value" id="bpmValue">120</span> <input type="range" class="bpm-slider" id="bpmSlider" value="120" min="60" max="200" step="1" title="Tempo BPM Slider">
    </div>
    
   </div>
   <div class="visualizer-container">
    <canvas class="visualizer" id="visualizer"></canvas>
   </div>
   <div class="timeline-container" style="overflow-wrap: anywhere; overflow-x: auto;">
    <div class="timeline-markers" id="timelineMarkers"><!-- Timeline markers will be populated by JavaScript -->
    </div>
    <div class="drum-grid" id="drumGrid"><!-- Grid will be populated by JavaScript -->
    </div>
   </div>
   <div class="volume-controls" id="volumeControls"><!-- Volume controls will be populated by JavaScript -->
   </div><button class="clear-button" id="clearButton" title="Clear all beats">Clear</button>
  </div>
   <!-- FX Modal / Splash -->
  <div id="fxModal" style="display:none; position:fixed; inset:0; align-items:center; justify-content:center; background:rgba(0,0,0,0.6); z-index:9999;">
    <div style="width:520px; max-width:92%; background:linear-gradient(#1b2730,#122024); padding:20px; border-radius:12px; color:#fff; box-shadow:0 10px 40px rgba(0,0,0,0.6);">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <div class="fx-title" style="font-weight:800">Track FX</div>
        <button class="fx-close" style="background:#2b2b2b;border:none;color:#fff;padding:6px 10px;border-radius:8px;cursor:pointer;">Close</button>
      </div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
        <div style="padding:10px; background:rgba(255,255,255,0.03); border-radius:8px;">
          <div style="font-weight:700;margin-bottom:8px;">EQ</div>
          <label>Low <input id="eqLow" type="range" min="-12" max="12" step="0.1" value="0"></label><br>
          <label>Mid <input id="eqMid" type="range" min="-12" max="12" step="0.1" value="0"></label><br>
          <label>High <input id="eqHigh" type="range" min="-12" max="12" step="0.1" value="0"></label>
        </div>
        <div style="padding:10px; background:rgba(255,255,255,0.03); border-radius:8px;">
          <div style="font-weight:700;margin-bottom:8px;">Dynamics</div>
          <label>Threshold <input id="compThresh" type="range" min="-60" max="0" step="0.1" value="-24"></label><br>
          <label>Ratio <input id="compRatio" type="range" min="1" max="20" step="0.1" value="4"></label>
        </div>
        <div style="grid-column:1/3; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px;">
          <div style="font-weight:700;margin-bottom:8px;">Reverb</div>
          <label>Wet <input id="reverbWet" type="range" min="0" max="1" step="0.01" value="0.2"></label>
        </div>
        <!-- Delay FX-->
        <div style="grid-column:1/3; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px;">
          <div style="font-weight:700;margin-bottom:8px;">Delay</div>
          <label>Time (ms) <input id="delayTime" type="range" min="0" max="1000" step="1" value="250"></label><br>
          <label>Feedback <input id="delayFeedback" type="range" min="0" max="0.95" step="0.01" value="0.3"></label><br>
          <label>Wet <input id="delayWet" type="range" min="0" max="1" step="0.01" value="0.2"></label>
      </div>
    </div>
  </div>
  </div>
  <div id="info-splash-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div id="info-splash" role="document" aria-label="Bangorinas information">
      <img src="./assets/BoomSlangLogo4.png" alt="BoomSlang Logo" class="img-fluid mb-3">
      <div class="meta">BoomSlang 1.0 — A Web-Based Beat Maker</div>
      <p>
        BoomSlang is a web-based beat maker that is open for everyone to use. It features a 16-step sequencer, multiple drum sounds, volume and pan controls, BPM adjustment, and audio effects like EQ, compression, and reverb. Create your own beats directly in the browser with an intuitive interface and real-time audio visualization.
      </p>
      <p class="meta" style="margin-top:1rem;">
        © <span id="year"></span> <a href="https://bangorinas.com" target="_blank" class="text-light">Bangorinas </a> | Music Production
      </p>
      <div class="actions">
        <button class="info-close-btn" id="info-splash-close">Close</button>
      </div>
    </div>
  </div>
  <div id="donate-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div id="donate-splash" role="document" aria-label="Bangorinas information">
      <img src="./assets/donate1.png" alt="BoomSlang Logo" class="img-fluid mb-3">
      <div class="meta">Donate — Support BoomSlang Development</div>
      <p style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem;">
        <a href="https://paypal.me/RanggaHermawan?locale.x=en_US&country.x=ID" target="_blank" class="info-primary-btn">PayPal</a>
        <a href="https://ko-fi.com/ranggafermata" target="_blank" class="info-primary-btn">Ko-fi</a>
        <img src="./assets/qrCode.png" alt="QR Code for Donation" style="max-width:500px; margin-top:1rem;">
      </p>
      <p class="meta" style="margin-top:1rem;">
        © <span id="year"></span> <a href="https://musicprod.bangorinas.com" target="_blank" class="text-light">Bangorinas </a> | Music Production
      </p>
      <div class="actions">
        <button class="donate-close-btn" id="donate-splash-close">Close</button>
      </div>
    </div>
  </div>
  <script>
    document.getElementById('year').textContent = new Date().getFullYear();
  </script>
<script>
    // Info splash logic: show when clicking the logo
    (function () {
      const logo = document.getElementById('appTitle');
      const overlay = document.getElementById('info-splash-overlay');
      const closeBtn = document.getElementById('info-splash-close');
      const openBtn = document.getElementById('info-splash-open');

      if (!logo || !overlay) return;

      function showInfo() {
        overlay.style.display = 'flex';
        requestAnimationFrame(() => {
          overlay.style.visibility = 'visible';
          overlay.style.opacity = '1';
          overlay.setAttribute('aria-hidden', 'false');
        });
        // trap focus briefly
        const focusable = overlay.querySelector('button') || overlay;
        if (focusable) focusable.focus();
      }

      function hideInfo() {
        overlay.style.opacity = '0';
        overlay.style.visibility = 'hidden';
        overlay.setAttribute('aria-hidden', 'true');
        overlay.addEventListener('transitionend', function onEnd(e) {
          if (e.propertyName === 'opacity') {
            overlay.style.display = 'none';
            overlay.removeEventListener('transitionend', onEnd);
          }
        });
      }

      logo.addEventListener('click', (e) => { e.preventDefault(); showInfo(); });
      if (closeBtn) closeBtn.addEventListener('click', hideInfo);
      if (openBtn) openBtn.addEventListener('click', () => {
        hideInfo();
        // focus main section to help keyboard users
        const main = document.getElementById('main-section');
        if (main) main.focus();
      });

      // Close on Esc or click outside dialog
      overlay.addEventListener('click', (ev) => {
        if (ev.target === overlay) hideInfo();
      });
      document.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape' && overlay.style.display === 'flex') hideInfo();
      });
    })();
  </script>
  <script>
    // Info splash logic: show when clicking the logo
    (function () {
      const logo = document.getElementById('donateButton');
      const overlay = document.getElementById('donate-overlay');
      const closeBtn = document.getElementById('donate-splash-close');
      const openBtn = document.getElementById('donate-splash-open');

      if (!logo || !overlay) return;

      function showInfo() {
        overlay.style.display = 'flex';
        requestAnimationFrame(() => {
          overlay.style.visibility = 'visible';
          overlay.style.opacity = '1';
          overlay.setAttribute('aria-hidden', 'false');
        });
        // trap focus briefly
        const focusable = overlay.querySelector('button') || overlay;
        if (focusable) focusable.focus();
      }

      function hideInfo() {
        overlay.style.opacity = '0';
        overlay.style.visibility = 'hidden';
        overlay.setAttribute('aria-hidden', 'true');
        overlay.addEventListener('transitionend', function onEnd(e) {
          if (e.propertyName === 'opacity') {
            overlay.style.display = 'none';
            overlay.removeEventListener('transitionend', onEnd);
          }
        });
      }

      logo.addEventListener('click', (e) => { e.preventDefault(); showInfo(); });
      if (closeBtn) closeBtn.addEventListener('click', hideInfo);
      if (openBtn) openBtn.addEventListener('click', () => {
        hideInfo();
        // focus main section to help keyboard users
        const main = document.getElementById('main-section');
        if (main) main.focus();
      });

      // Close on Esc or click outside dialog
      overlay.addEventListener('click', (ev) => {
        if (ev.target === overlay) hideInfo();
      });
      document.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape' && overlay.style.display === 'flex') hideInfo();
      });
    })();
  </script>
  <script>
        class BeatMaker {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.isPlaying = false;
                this.currentStep = 0;
                this.bpm = 120;
                this.stepInterval = null;
                this.analyser = null;
                this.dataArray = null;
                this.canvas = null;
                this.canvasContext = null;
                this.masterVolume = 0.8; // 0.0 - 1.0
                this.pans = {};
                // manualMute: user toggles via M button
                this.manualMuted = {};
                // soloed: user toggles via S button
                this.soloed = {};
                // effectiveMuted: computed from manualMuted + soloed logic
                this.effectiveMuted = {};

                // Preset banks (URLs). If a URL fails to load, fallback synthesized sound will be used.
                this.presets = {
                    classic: {
                        kick: 'https://raw.githubusercontent.com/ranggafermata/AlienMetarockBananaBeats/main/01_Kick.wav',
                        snare: 'https://raw.githubusercontent.com/ranggafermata/AlienMetarockBananaBeats/main/02_Snare.wav',
                        hihat: 'https://raw.githubusercontent.com/ranggafermata/AlienMetarockBananaBeats/main/04_HiHat_1.wav',
                        openhat: 'https://raw.githubusercontent.com/ranggafermata/AlienMetarockBananaBeats/main/06_Open HiHat.wav',
                        crash: 'https://raw.githubusercontent.com/ranggafermata/AlienMetarockBananaBeats/main/07_Crash.wav',
                        clap: 'https://raw.githubusercontent.com/ranggafermata/AlienMetarockBananaBeats/main/03_Clap.wav',
                        fx: 'https://raw.githubusercontent.com/ranggafermata/AlienMetarockBananaBeats/main/11_Fx_2.wav'
                    },
                    electronic: {
                        // alternative sample URLs (may fallback to synth if unavailable)
                        kick: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Full House/Kick.wav ',
                        snare: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Full House/Snare.wav',
                        hihat: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Full House/Hi-hat.wav',
                        openhat: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Full House/Op-hat.wav',
                        crash: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Full House/Crash.wav',
                        clap: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Full House/Clap.wav',
                        fx: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Full House/FxVox.wav'
                    },
                    acoustic: {
                        kick: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Trapper/Kick.wav',
                        snare: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Trapper/Snare.wav',
                        hihat: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Trapper/Hi-hat.wav',
                        openhat: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Trapper/Op-hat.wav',
                        crash: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Trapper/Crash.wav',
                        clap: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Trapper/Clap.wav',
                        fx: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Trapper/Fx.wav'
                    },
                    Pop: {
                        kick: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Sweet Candy/Kick.wav',
                        snare: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Sweet Candy/Snare.wav',
                        hihat: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Sweet Candy/Hi-hat.wav',
                        openhat: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Sweet Candy/Op-hat.wav',
                        crash: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Sweet Candy/Crash.wav',
                        clap: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Sweet Candy/Clap.wav',
                        fx: 'https://raw.githubusercontent.com/ranggafermata/BoomSlangPresets/main/Sweet Candy/Fx.wav'
                    },
                    default: {
                        kick: '',
                        snare: '',
                        hihat: '',
                        openhat: '',
                        crash: '',
                        clap: '',
                        fx: ''
                    }
                };

                // Drum configuration - initial bank uses the classic preset
                this.drums = {
                    kick: { name: 'Kick', color: 'kick', volume: 0.8, buffer: null, url: this.presets.classic.kick },
                    snare: { name: 'Snare', color: 'snare', volume: 0.6, buffer: null, url: this.presets.classic.snare },
                    hihat: { name: 'Hi-Hat', color: 'hihat', volume: 0.4, buffer: null, url: this.presets.classic.hihat },
                    openhat: { name: 'Open Hat', color: 'openhat', volume: 0.5, buffer: null, url: this.presets.classic.openhat },
                    crash: { name: 'Crash', color: 'crash', volume: 0.7, buffer: null, url: this.presets.classic.crash },
                    clap: { name: 'Clap', color: 'clap', volume: 0.6, buffer: null, url: this.presets.classic.clap },
                    fx: { name: 'FX', color: 'fx', volume: 0.5, buffer: null, url: this.presets.classic.fx }
                };

                this.pattern = {};
                this.steps = 16;

                this.initializePattern();
                this.setupUI();
                this.setupAudio();
                this.setupVisualizer();
                this.loadSounds();

                // initialize mute/solo state maps
                Object.keys(this.drums).forEach(drumKey => {
                    this.manualMuted[drumKey] = false;
                    this.soloed[drumKey] = false;
                    this.effectiveMuted[drumKey] = false;
                });
            }

            setPan(drumKey, panValue) {
               this.pans[drumKey] = panValue;
               if (this.fxNodes && this.fxNodes[drumKey] && this.fxNodes[drumKey].panner) {
                   this.fxNodes[drumKey].panner.pan.value = panValue;
               }
           }

            async loadSounds() {
                // Load audio files from GitHub repository
                for (const drumKey in this.drums) {
                    try {
                        // Use mode: 'cors' to handle cross-origin requests properly
                        const response = await fetch(this.drums[drumKey].url, {
                            mode: 'cors',
                            credentials: 'omit'
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const arrayBuffer = await response.arrayBuffer();
                        this.drums[drumKey].buffer = await this.audioContext.decodeAudioData(arrayBuffer);
                        console.log(`Successfully loaded sound for ${drumKey}`);
                    } catch (error) {
                        console.warn(`Using synthesized sound for ${drumKey} (couldn't load from GitHub):`, error.message);
                        // Fallback to synthesized sound if loading fails
                        this.drums[drumKey].buffer = null;
                    }
                }
            }

            applyPreset(presetKey) {
                const preset = this.presets[presetKey];
                if (!preset) return;
                Object.keys(preset).forEach(drumKey => {
                    if (this.drums[drumKey]) {
                        // update url and clear previously decoded buffer so it will be reloaded
                        this.drums[drumKey].url = preset[drumKey];
                        this.drums[drumKey].buffer = null;
                    }
                });
                // reload samples (async, errors fall back to synth)
                this.loadSounds();
            }

            initializePattern() {
                Object.keys(this.drums).forEach(drum => {
                    this.pattern[drum] = new Array(this.steps).fill(false);
                });
            }

            createTimelineMarkers() {
                const timeline = document.getElementById('timelineMarkers');
                timeline.innerHTML = '';
                
                // Add spacer for drum label column
                const spacer = document.createElement('div');
                spacer.className = 'timeline-spacer';
                timeline.appendChild(spacer);
                
                // Create markers for each step
                for (let step = 0; step < this.steps; step++) {
                    const marker = document.createElement('div');
                    marker.className = 'beat-marker';
                    
                    // Determine marker type and label
                    if (step % 4 === 0) {
                        // Quarter note (main beats: 1, 2, 3, 4)
                        marker.classList.add('quarter');
                        marker.textContent = (step / 4) + 1;
                    } else if (step % 2 === 0) {
                        // Eighth note (& beats)
                        marker.classList.add('eighth');
                        marker.textContent = '&';
                    } else {
                        // Sixteenth note (e & a beats)
                        marker.textContent = step % 4 === 1 ? 'e' : 'a';
                    }
                    
                    marker.dataset.step = step;
                    timeline.appendChild(marker);
                }
            }

            createDrumGrid() {
                const grid = document.getElementById('drumGrid');
                grid.innerHTML = '';

                Object.keys(this.drums).forEach(drumKey => {
                    const drum = this.drums[drumKey];
                    
                    // Create drum label
                    const label = document.createElement('div');
                    label.className = `drum-label ${drum.color}`;
                    label.textContent = drum.name;
                    label.style.cursor = 'pointer';
                    label.title = `Click to adjust Effects for ${drum.name}`;
                    // open FX modal when label clicked
                    label.addEventListener('click', () => {
                        this.openFXModal(drumKey);
                    });
                    grid.appendChild(label);
                    
                    // Create step buttons
                    for (let step = 0; step < this.steps; step++) {
                        const button = document.createElement('button');
                        button.className = 'step-button';
                        button.dataset.drum = drumKey;
                        button.dataset.step = step;
                        
                        button.addEventListener('click', () => {
                            this.toggleStep(drumKey, step);
                            this.updateStepButton(button, drumKey, step);
                        });
                        
                        grid.appendChild(button);
                    }
                });
            }

            // --- FX modal UI ---
            openFXModal(drumKey) {
                // ensure FX nodes exist
                if (!this.fxNodes || !this.fxNodes[drumKey]) this.createTrackFX(drumKey);
                const fx = this.fxNodes[drumKey];
                const modal = document.getElementById('fxModal');
                modal.dataset.drum = drumKey;
                modal.querySelector('.fx-title').textContent = `${this.drums[drumKey].name} — FX`;

                // populate UI with current node values
                modal.querySelector('#eqLow').value = fx.low.gain ? fx.low.gain.value : 0;
                modal.querySelector('#eqMid').value = fx.mid.gain ? fx.mid.gain.value : 0;
                modal.querySelector('#eqHigh').value = fx.high.gain ? fx.high.gain.value : 0;
                modal.querySelector('#compThresh').value = fx.comp.threshold ? fx.comp.threshold.value : -24;
                modal.querySelector('#compRatio').value = fx.comp.ratio ? fx.comp.ratio.value : 4;
                modal.querySelector('#reverbWet').value = fx.reverbWet && fx.reverbWet.gain ? fx.reverbWet.gain.value : 0.2;
                modal.querySelector('#delayTime').value = fx.delay && fx.delay.delayTime ? fx.delay.delayTime.value * 1000 : 250;
                modal.querySelector('#delayFeedback').value = fx.delayFeedback && fx.delayFeedback.gain ? fx.delayFeedback.gain.value : 0.3;
                modal.querySelector('#delayWet').value = fx.delayWet && fx.delayWet.gain ? fx.delayWet.gain.value : 0.2;

                modal.style.display = 'flex';
            }

            setupUI() {
                this.createTimelineMarkers();
                this.createDrumGrid();
                this.createVolumeControls();
                this.setupEventListeners();
                this.setupMasterControl();
                // fx modal listeners (no audioContext required)
                this.setupFXModalListeners();
            }

            setupFXModalListeners() {
                const modal = document.getElementById('fxModal');
                
                // Close button listener
                const closeBtn = modal.querySelector('.fx-close');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => this.closeFXModal());
                }

                // EQ Low
                const eqLow = modal.querySelector('#eqLow');
                if (eqLow) {
                    eqLow.addEventListener('input', (e) => {
                        const drumKey = modal.dataset.drum;
                        if (this.fxNodes && this.fxNodes[drumKey]) {
                            this.fxNodes[drumKey].low.gain.value = parseFloat(e.target.value);
                        }
                    });
                }

                // EQ Mid
                const eqMid = modal.querySelector('#eqMid');
                if (eqMid) {
                    eqMid.addEventListener('input', (e) => {
                        const drumKey = modal.dataset.drum;
                        if (this.fxNodes && this.fxNodes[drumKey]) {
                            this.fxNodes[drumKey].mid.gain.value = parseFloat(e.target.value);
                        }
                    });
                }

                // EQ High
                const eqHigh = modal.querySelector('#eqHigh');
                if (eqHigh) {
                    eqHigh.addEventListener('input', (e) => {
                        const drumKey = modal.dataset.drum;
                        if (this.fxNodes && this.fxNodes[drumKey]) {
                            this.fxNodes[drumKey].high.gain.value = parseFloat(e.target.value);
                        }
                    });
                }

                // Compressor Threshold
                const compThresh = modal.querySelector('#compThresh');
                if (compThresh) {
                    compThresh.addEventListener('input', (e) => {
                        const drumKey = modal.dataset.drum;
                        if (this.fxNodes && this.fxNodes[drumKey]) {
                            this.fxNodes[drumKey].comp.threshold.value = parseFloat(e.target.value);
                        }
                    });
                }

                // Compressor Ratio
                const compRatio = modal.querySelector('#compRatio');
                if (compRatio) {
                    compRatio.addEventListener('input', (e) => {
                        const drumKey = modal.dataset.drum;
                        if (this.fxNodes && this.fxNodes[drumKey]) {
                            this.fxNodes[drumKey].comp.ratio.value = parseFloat(e.target.value);
                        }
                    });
                }

                // Reverb Wet
                const reverbWet = modal.querySelector('#reverbWet');
                if (reverbWet) {
                    reverbWet.addEventListener('input', (e) => {
                        const drumKey = modal.dataset.drum;
                        if (this.fxNodes && this.fxNodes[drumKey]) {
                            this.fxNodes[drumKey].reverbWet.gain.value = parseFloat(e.target.value);
                        }
                    });
                }

                // Delay Time
                const delayTime = modal.querySelector('#delayTime');
                if (delayTime) {
                    delayTime.addEventListener('input', (e) => {
                        const drumKey = modal.dataset.drum;
                        if (this.fxNodes && this.fxNodes[drumKey] && this.fxNodes[drumKey].delay) {
                            this.fxNodes[drumKey].delay.delayTime.value = parseFloat(e.target.value) / 1000;
                        }
                    });
                }
                // Delay Feedback
                const delayFeedback = modal.querySelector('#delayFeedback');
                if (delayFeedback) {
                    delayFeedback.addEventListener('input', (e) => {
                        const drumKey = modal.dataset.drum;
                        if (this.fxNodes && this.fxNodes[drumKey] && this.fxNodes[drumKey].delayFeedback) {
                            this.fxNodes[drumKey].delayFeedback.gain.value = parseFloat(e.target.value);
                        }
                    });
                }
                // Delay Wet
                const delayWet = modal.querySelector('#delayWet');
                if (delayWet) {
                    delayWet.addEventListener('input', (e) => {
                        const drumKey = modal.dataset.drum;
                        if (this.fxNodes && this.fxNodes[drumKey] && this.fxNodes[drumKey].delayWet) {
                            this.fxNodes[drumKey].delayWet.gain.value = parseFloat(e.target.value);
                        }
                    });
                }
            }

            closeFXModal() {
                const modal = document.getElementById('fxModal');
                modal.style.display = 'none';
            }

            createVolumeControls() {
                const container = document.getElementById('volumeControls');
                container.innerHTML = '';

                Object.keys(this.drums).forEach(drumKey => {
                    const drum = this.drums[drumKey];
                    
                    const control = document.createElement('div');
                    control.className = 'volume-control';
                    
                    control.innerHTML = `
                        <div class="volume-label">${drum.name}</div>
                        <div class="knob-container" title="Volume for ${drum.name}">
                            <div class="knob" data-drum="${drumKey}">
                                <div class="knob-indicator" data-drum="${drumKey}"></div>
                                <div class="knob-value" data-drum="${drumKey}">${Math.round(drum.volume * 100)}</div>
                            </div>
                        </div>
                        <div style="width:100%; padding:0 10px; margin-top:8px;" title="Left/right position for ${drum.name}">
                            <label style="font-size:0.75rem; color:#4ecdc4; display:block; margin-bottom:4px;">Pan</label>
                            <input type="range" class="pan-slider" data-drum="${drumKey}" min="-1" max="1" step="0.1" value="0" style="width:100%; cursor:pointer;">
                        </div>
                        <div style="width:100%; display:flex; gap:6px; margin-top:10px; padding:0 10px;" title="Mute (M) or Solo (S) ${drum.name} track">
                            <button class="mute-btn" data-drum="${drumKey}" style="flex:1; padding:6px; background:#ff6b6b; border:none; border-radius:6px; color:#fff; font-size:0.75rem; font-weight:bold; cursor:pointer; transition:all 0.2s;">M</button>
                            <button class="solo-btn" data-drum="${drumKey}" style="flex:1; padding:6px; background:#4ecdc4; border:none; border-radius:6px; color:#000; font-size:0.75rem; font-weight:bold; cursor:pointer; transition:all 0.2s;">S</button>
                        </div>
                    `;
                    
                    const knob = control.querySelector('.knob');
                    const indicator = control.querySelector('.knob-indicator');
                    const valueDisplay = control.querySelector('.knob-value');
                    const panSlider = control.querySelector('.pan-slider');
                    const muteBtn = control.querySelector('.mute-btn');
                    const soloBtn = control.querySelector('.solo-btn');
                    
                    let isDragging = false;
                    let startY = 0;
                    let startValue = drum.volume;
                    
                    const updateKnob = (value) => {
                        const angle = (value * 270) - 135;
                        indicator.style.transform = `translateX(-50%) rotate(${angle}deg)`;
                        valueDisplay.textContent = Math.round(value * 100);
                        this.drums[drumKey].volume = value;
                    };
                    
                    updateKnob(drum.volume);
                    
                    knob.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        startY = e.clientY;
                        startValue = this.drums[drumKey].volume;
                        e.preventDefault();
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        
                        const deltaY = startY - e.clientY;
                        const sensitivity = 0.005;
                        let newValue = startValue + (deltaY * sensitivity);
                        newValue = Math.max(0, Math.min(1, newValue));
                        
                        updateKnob(newValue);
                    });
                    
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                    
                    knob.addEventListener('touchstart', (e) => {
                        isDragging = true;
                        startY = e.touches[0].clientY;
                        startValue = this.drums[drumKey].volume;
                        e.preventDefault();
                    });
                    
                    document.addEventListener('touchmove', (e) => {
                        if (!isDragging) return;
                        
                        const deltaY = startY - e.touches[0].clientY;
                        const sensitivity = 0.005;
                        let newValue = startValue + (deltaY * sensitivity);
                        newValue = Math.max(0, Math.min(1, newValue));
                        
                        updateKnob(newValue);
                    });
                    
                    document.addEventListener('touchend', () => {
                        isDragging = false;
                    });

                    panSlider.addEventListener('input', (e) => {
                        const panValue = parseFloat(e.target.value);
                        this.setPan(drumKey, panValue);
                    });

                    // Mute button -> toggles manual mute
                    muteBtn.addEventListener('click', () => {
                        this.toggleMute(drumKey);
                        // update UI immediately
                        muteBtn.style.opacity = this.manualMuted[drumKey] ? '1' : '0.5';
                        // recompute effective mutes and reflect on UI
                        this.computeEffectiveMutes();
                        this.refreshMuteSoloUI();
                    });

                    // Solo button -> toggles solo state
                    soloBtn.addEventListener('click', () => {
                        this.toggleSolo(drumKey);
                        // recompute effective mutes and reflect on UI
                        this.computeEffectiveMutes();
                        this.refreshMuteSoloUI();
                    });

                    // set initial UI state for buttons
                    muteBtn.style.opacity = this.manualMuted[drumKey] ? '1' : '0.5';
                    soloBtn.style.opacity = this.soloed[drumKey] ? '1' : '0.5';
                     
                    
                    container.appendChild(control);
                });
            }


            setupEventListeners() {
                document.getElementById('playButton').addEventListener('click',() => {
                    this.togglePlayback();
                });

                document.getElementById('bpmSlider').addEventListener('input', (e) => {
                    const bpm = parseInt(e.target.value);
                    this.setBPM(bpm);
                    document.getElementById('bpmValue').textContent = bpm;
                });

                document.getElementById('clearButton').addEventListener('click', () => {
                    this.clearPattern();
                });
            }

            // --- FX: create FX chains for all tracks after audioContext is available ---
            createAllTrackFX() {
                this.fxNodes = this.fxNodes || {};
                Object.keys(this.drums).forEach(drumKey => this.createTrackFX(drumKey));
            }

            createTrackFX(drumKey) {
                if (!this.audioContext) return;
                // create per-track FX nodes
                const ctx = this.audioContext;
                const input = ctx.createGain();
                const panner = ctx.createStereoPanner();
                panner.pan.value = this.pans[drumKey] || 0;
                const low = ctx.createBiquadFilter(); low.type = 'lowshelf'; low.frequency.value = 200;
                const mid = ctx.createBiquadFilter(); mid.type = 'peaking'; mid.frequency.value = 1000; mid.Q.value = 1;
                const high = ctx.createBiquadFilter(); high.type = 'highshelf'; high.frequency.value = 5000;
                const comp = ctx.createDynamicsCompressor();
                const reverb = ctx.createConvolver();
                const reverbWet = ctx.createGain(); reverbWet.gain.value = 0.0;
                const dry = ctx.createGain(); dry.gain.value = 1.0;
                const delay = ctx.createDelay(1.0);
                const delayFeedback = ctx.createGain();
                const delayWet = ctx.createGain();
                delayWet.gain.value = 0.0;
                delayFeedback.gain.value = 0.3;
                delay.delayTime.value = 0.25;

                // generate a small impulse response for the convolver
                reverb.buffer = this._generateReverbImpulse(ctx, 2.0, 2.0);

                // chain: input -> EQ (low->mid->high) -> split: dry + reverb -> delay -> comp -> analyser 
                input.connect(panner);
                panner.connect(low);
                low.connect(mid);
                mid.connect(high);

                high.connect(dry);
                high.connect(reverb);

                reverb.connect(reverbWet);
                // merge wet + dry -> compressor -> analyser (visual)
                dry.connect(comp);
                reverbWet.connect(comp);
                comp.connect(this.analyser);

                // delay loop
                high.connect(delay);
                delay.connect(delayFeedback);
                delayFeedback.connect(delay);
                delay.connect(delayWet);
                delayWet.connect(comp);

                this.fxNodes[drumKey] = {
                    input, panner, low, mid, high, comp, reverb, reverbWet, dry, delay, delayFeedback, delayWet
                };
            }

            _generateReverbImpulse(ctx, duration = 2.0, decay = 2.0) {
                const sr = ctx.sampleRate;
                const length = sr * duration;
                const impulse = ctx.createBuffer(2, length, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const channelData = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        const n = length - i;
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
                    }
                }
                return impulse;
            }

            _generateDelayImpulse(ctx, delayTime = 0.5) {
                const sr = ctx.sampleRate;
                const length = sr * delayTime;
                const impulse = ctx.createBuffer(1, length, sr);
                const channelData = impulse.getChannelData(0);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (i === 0) ? 1.0 : 0.0;
                }
                return impulse;
            }

            getFXInput(drumKey) {
                if (this.fxNodes && this.fxNodes[drumKey]) return this.fxNodes[drumKey].input;
                return this.analyser; // fallback
            }


            async setupAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Create master gain and analyser for visualization
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.masterVolume;

                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;

                    // Chain: source -> per-sound gain/filter -> analyser -> masterGain -> destination
                    this.analyser.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);

                    const bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(bufferLength);
                    // create per-track FX chains now that audioContext exists
                    this.createAllTrackFX();
                } catch (error) {
                    console.error('Audio setup failed:', error);
                }
            }

            setupVisualizer() {
                this.canvas = document.getElementById('visualizer');
                this.canvasContext = this.canvas.getContext('2d');
                
                // Set canvas size
                const resizeCanvas = () => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.canvas.width = rect.width * window.devicePixelRatio;
                    this.canvas.height = rect.height * window.devicePixelRatio;
                    this.canvasContext.scale(window.devicePixelRatio, window.devicePixelRatio);
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                this.drawVisualizer();
            }

            drawVisualizer() {
                requestAnimationFrame(() => this.drawVisualizer());
                
                const canvas = this.canvas;
                const ctx = this.canvasContext;
                const rect = canvas.getBoundingClientRect();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(0, 0, rect.width, rect.height);
                
                if (this.analyser && this.dataArray) {
                    this.analyser.getByteFrequencyData(this.dataArray);
                    
                    const barWidth = rect.width / this.dataArray.length;
                    let x = 0;
                    
                    for (let i = 0; i < this.dataArray.length; i++) {
                        const barHeight = (this.dataArray[i] / 255) * rect.height;
                        
                        const hue = (i / this.dataArray.length) * 360;
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        
                        ctx.fillRect(x, rect.height - barHeight, barWidth, barHeight);
                        x += barWidth;
                    }
                }
            }

            createDrumSound(type) {
                if (!this.audioContext) return null;

                const drum = this.drums[type];
                
                // Use loaded sound buffer if available, otherwise fallback to synthesized sound
                if (drum.buffer) {
                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    source.buffer = drum.buffer;
                    gainNode.gain.value = drum.volume;
                    source.connect(gainNode);
                    // route through per-track FX input (so FX affects each track)
                    gainNode.connect(this.getFXInput(type));
                    source.start(0);
                    return source;
                } else {
                    // Fallback to synthesized sounds
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    // connect synth output to track FX input
                    gainNode.connect(filter);
                    filter.connect(this.getFXInput(type));
                    
                    const now = this.audioContext.currentTime;
                    
                    switch (type) {
                        case 'kick':
                            oscillator.frequency.setValueAtTime(60, now);
                            oscillator.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
                            gainNode.gain.setValueAtTime(drum.volume, now);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                            filter.frequency.setValueAtTime(100, now);
                            break;
                            
                        case 'snare':
                            oscillator.frequency.setValueAtTime(200, now);
                            gainNode.gain.setValueAtTime(drum.volume, now);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                            filter.frequency.setValueAtTime(1000, now);
                            break;
                            
                        case 'hihat':
                            oscillator.frequency.setValueAtTime(8000, now);
                            gainNode.gain.setValueAtTime(drum.volume, now);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                            filter.type = 'highpass';
                            filter.frequency.setValueAtTime(7000, now);
                            break;
                            
                        case 'openhat':
                            oscillator.frequency.setValueAtTime(6000, now);
                            gainNode.gain.setValueAtTime(drum.volume, now);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                            filter.type = 'highpass';
                            filter.frequency.setValueAtTime(5000, now);
                            break;
                            
                        case 'crash':
                            oscillator.frequency.setValueAtTime(4000, now);
                            gainNode.gain.setValueAtTime(drum.volume, now);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                            filter.frequency.setValueAtTime(2000, now);
                            break;
                    }
                    
                    oscillator.connect(gainNode);
                    oscillator.start(now);
                    oscillator.stop(now + 1);
                    
                    return oscillator;
                }
            }


            setupMasterControl() {
                const knob = document.getElementById('masterKnob');
                const indicator = document.getElementById('masterIndicator');
                const valueDisplay = document.getElementById('masterValue');
                const presetSelect = document.getElementById('presetSelect');

                let isDragging = false;
                let startY = 0;
                let startValue = this.masterVolume;

                const updateMaster = (value) => {
                    this.masterVolume = value;
                    if (this.masterGain) this.masterGain.gain.value = value;
                    const angle = (value * 270) - 135;
                    indicator.style.transform = `translateX(-50%) rotate(${angle}deg)`;
                    valueDisplay.textContent = Math.round(value * 100);
                };

                updateMaster(this.masterVolume);

                knob.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startValue = this.masterVolume;
                    e.preventDefault();
                });
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const deltaY = startY - e.clientY;
                    const sensitivity = 0.005;
                    let newValue = startValue + (deltaY * sensitivity);
                    newValue = Math.max(0, Math.min(1, newValue));
                    updateMaster(newValue);
                });
                document.addEventListener('mouseup', () => isDragging = false);

                // touch support
                knob.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    startY = e.touches[0].clientY;
                    startValue = this.masterVolume;
                    e.preventDefault();
                });
                document.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    const deltaY = startY - e.touches[0].clientY;
                    const sensitivity = 0.005;
                    let newValue = startValue + (deltaY * sensitivity);
                    newValue = Math.max(0, Math.min(1, newValue));
                    updateMaster(newValue);
                });
                document.addEventListener('touchend', () => isDragging = false);

                // preset selector change
                presetSelect.addEventListener('change', (e) => {
                    const presetKey = e.target.value;
                    this.applyPreset(presetKey);
                });
            }

            toggleStep(drum, step) {
                this.pattern[drum][step] = !this.pattern[drum][step];
            }

            updateStepButton(button, drum, step) {
                if (this.pattern[drum][step]) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            }

            async togglePlayback() {
                if (!this.audioContext) {
                    await this.setupAudio();
                }
                
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                
                const playButton = document.getElementById('playButton');
                
                if (this.isPlaying) {
                    this.stop();
                    playButton.textContent = '▶';
                    playButton.classList.remove('playing');
                } else {
                    this.play();
                    playButton.textContent = '⏸';
                    playButton.classList.add('playing');
                }
            }

            play() {
                this.isPlaying = true;
                const stepDuration = (60 / this.bpm / 4) * 1000; // 16th notes
                
                this.stepInterval = setInterval(() => {
                    this.playStep();
                    this.updateCurrentStepDisplay();
                    this.currentStep = (this.currentStep + 1) % this.steps;
                }, stepDuration);
            }

            stop() {
                this.isPlaying = false;
                if (this.stepInterval) {
                    clearInterval(this.stepInterval);
                    this.stepInterval = null;
                }
                this.currentStep = 0;
                this.updateCurrentStepDisplay();
            }

            // Toggle manual mute
           toggleMute(drumKey) {
               this.manualMuted[drumKey] = !this.manualMuted[drumKey];
           }

           // Toggle solo
           toggleSolo(drumKey) {
               this.soloed[drumKey] = !this.soloed[drumKey];
           }

           // Compute effective mute state: if any soloed -> only soloed tracks play,
           // otherwise use manualMuted values.
           computeEffectiveMutes() {
               const anySoloed = Object.values(this.soloed).some(Boolean);
               Object.keys(this.drums).forEach(drumKey => {
                   if (anySoloed) {
                       this.effectiveMuted[drumKey] = !this.soloed[drumKey];
                   } else {
                       this.effectiveMuted[drumKey] = !!this.manualMuted[drumKey];
                   }
               });
           }

           // Update DOM UI for mute/solo buttons (opacity/visuals).
           refreshMuteSoloUI() {
               // find all controls and adjust styles
               const container = document.getElementById('volumeControls');
               if (!container) return;
               const controls = container.querySelectorAll('.volume-control');
               controls.forEach(control => {
                   const muteBtn = control.querySelector('.mute-btn');
                   const soloBtn = control.querySelector('.solo-btn');
                   const drumKey = muteBtn && muteBtn.dataset ? muteBtn.dataset.drum : null;
                   if (!drumKey) return;

                   // manual mute button style
                   if (muteBtn) muteBtn.style.opacity = this.manualMuted[drumKey] ? '1' : '0.5';

                   // solo button style
                   if (soloBtn) soloBtn.style.opacity = this.soloed[drumKey] ? '1' : '0.5';
               });
           }

            playStep() {
                // ensure effective mute map is up-to-date
                this.computeEffectiveMutes();
                Object.keys(this.drums).forEach(drumKey => {
                    if (this.pattern[drumKey][this.currentStep] && !this.effectiveMuted[drumKey]) {
                        this.createDrumSound(drumKey);
                    }
                });
            }

            updateCurrentStepDisplay() {
                const buttons = document.querySelectorAll('.step-button');
                buttons.forEach((button, index) => {
                    const step = index % this.steps;
                    if (step === this.currentStep && this.isPlaying) {
                        button.classList.add('current');
                    } else {
                        button.classList.remove('current');
                    }
                });
                
                // Highlight current beat marker
                const markers = document.querySelectorAll('.beat-marker');
                markers.forEach((marker, index) => {
                    if (index === this.currentStep && this.isPlaying) {
                        marker.style.transform = 'scale(1.15)';
                        marker.style.boxShadow = '0 0 20px rgba(78, 205, 196, 0.8)';
                    } else {
                        marker.style.transform = 'scale(1)';
                        marker.style.boxShadow = 'none';
                    }
                });
            }

            setBPM(newBPM) {
                this.bpm = Math.max(60, Math.min(200, newBPM));
                document.getElementById('bpmSlider').value = this.bpm;
                document.getElementById('bpmValue').textContent = this.bpm;
                
                if (this.isPlaying) {
                    this.stop();
                    this.play();
                }
            }

            clearPattern() {
                this.initializePattern();
                const buttons = document.querySelectorAll('.step-button');
                buttons.forEach(button => {
                    button.classList.remove('active');
                });
            }
        }

        // Initialize the beat maker when page loads
        let beatMaker;
        
        // Element SDK Configuration
        const defaultConfig = {
            app_title: "BoomSlang Beat Maker",
            bpm_label: "BPM"
        };

        async function onConfigChange(config) {
            const appTitle = config.app_title || defaultConfig.app_title;
            const bpmLabel = config.bpm_label || defaultConfig.bpm_label;
            
            document.getElementById('appTitle').textContent = appTitle;
            document.getElementById('bpmLabel').textContent = bpmLabel;
        }

        function mapToCapabilities(config) {
            return {
                recolorables: [],
                borderables: [],
                fontEditable: undefined,
                fontSizeable: undefined
            };
        }

        function mapToEditPanelValues(config) {
            return new Map([
                ["app_title", config.app_title || defaultConfig.app_title],
                ["bpm_label", config.bpm_label || defaultConfig.bpm_label]
            ]);
        }

        // Initialize everything when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            beatMaker = new BeatMaker();
            
            if (window.elementSdk) {
                window.elementSdk.init({
                    defaultConfig,
                    onConfigChange,
                    mapToCapabilities,
                    mapToEditPanelValues
                });
            }
        });

        


    </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9a77ddb680b8ea76',t:'MTc2NDY0NzQ4OS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>